---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->
<!-- You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# xsdm

<!-- badges: start -->
<!-- badges: end -->

The goal of xsdm is to model the distribution of species.
The main difference of xsdm from the other species' distribution models (SDMs) is that xsdm incorporate inter-annual climatic variabiliy when estimating the suitability of species.
This is achieved using theory from stochastic demography.

## Installation

You can install the development version of xsdm from GitHub using the `devtools` package:

``` r
devtools::install_github("emilio-berti/xsdm")
```

## XSDM using the Lewontin-Cohen model

For the sake of simplicity, we will focus on a species that has few recorded observations ($n = 20$) and which distribution depends only on one climatic predictor.
In general, we recommend to run XSDM for species that have at least $n = #$.
In addition, the distribution of most species is likely influenced by more than one climatic factor.
See section ... for an example of selecting important variables using model selection.

First we generate a fake time series of one climatic variable:
```{r timeseries}
library(xsdm)
library(terra)

# fake time serie of first climatic variable -----------
for (i in seq_len(10)) {
  if (i == 1) {
    r <- rast(matrix(rnorm(1e4, 30, 10), 1e2, 1e2))
  } else {
    r <- c(r, rast(matrix(rnorm(1e4, 30, 10), 1e2, 1e2)))
  }
}
```

Then, we create a virtual species with niche parameters `mu`, `sigl` and `sigr` and observation parameters `c` and `pd`.
We also sample location at which we sampled the occurrence of this species:

```{r virtual}
# uni-dimensional niche
lambda <- function(x, mu, sigl, sigr) {
  u <- x - mu
  u[u <= 0] <- (u[u <= 0] / sigl) ^ 2
  u[u > 0] <- (u[u > 0] / sigr) ^ 2
  lambda <- exp(-0.5 * u)
  return(lambda)
}

# probability of detection
pr <- function(x, c, pd) {
  return (pd / (1 + exp(c - x)))
}

# species parameters
pars <- list(mu = 25, sigl = 2, sigr = 10, c = -5, pd = 0.9)

# location vector
p <- runif(500, 0, 100)
p <- vect(matrix(p, ncol = 2))

# occurrence at locations
r_vals <- as.matrix(terra::extract(r, p))
lambdas <- lambda(
  as.matrix(r_vals),
  mu = pars$mu, sigl = pars$sigl, sigr = pars$sigr
)
ltsgr <- rowMeans(log(lambdas))
P <- pr(ltsgr, c = pars$c, pd = pars$pd)
p$occ <- rbinom(length(p), 1, prob = P)
table(p$occ)
```

Let's look at the actual niche of this species:

```{r show}
oldpar <- par(no.readonly = TRUE)
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(
  sort(r_vals), lambdas[order(r_vals)], 
  type = "l", frame = FALSE,
  xlab = expression("Climate (e"[t]*")"),
  ylab = expression(lambda[t]),
)
plot(
  rowMeans(r_vals), ltsgr, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "ltsgr",
)
plot(
  rowMeans(r_vals), P, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Probability of detection",
)
plot(
  rowMeans(r_vals), p$occ, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Occurrence",
)
par(oldpar)
```

We are then ready to fit XSDM using the Lewontin-Cohen model and one climatic predictor: 

```{r xsdm, cache=TRUE}
scaled_r <- scale(r)          # scaling helps with fitting
niche <- lewontin_cohen(
  list(r), p,                 # first argument should always be a list
  warmup = 500, iter = 1000,  # only as example; you need more than this
  cores = 4, chains = 4,
  refresh = 10
)

rstan::traceplot(niche, pars = c("mu", "sigl", "sigr", "c", "pd"))
summary(niche, c("mu", "sigl", "sigr", "c", "pd"))$summary
rstan::extract(niche, c("mu"))

```
