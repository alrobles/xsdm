---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->
<!-- You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# xsdm

<!-- badges: start -->
<!-- badges: end -->

The goal of xsdm is to model the distribution of species.
The main difference of xsdm from the other species' distribution models (SDMs) is that xsdm incorporate inter-annual climatic variabiliy when estimating the suitability of species.
This is achieved using theory from stochastic demography.

## Installation

You can install the development version of xsdm from GitHub using the `devtools` package:

``` r
devtools::install_github("emilio-berti/xsdm")
```

## Example

This, as the other examples in this vignette ...


Let's create some fake climate time series and a virtual species that lives in it:

```{r example}
library(xsdm)
library(terra)

# fake time serie of one climatic variable
for (i in seq_len(10)) {
  if (i == 1) {
    r <- rast(matrix(rnorm(1e4), 1e2, 1e2))
  } else {
    r <- c(r, rast(matrix(rnorm(1e4), 1e2, 1e2)))
  }
}
names(r) <- seq_len(nlyr(r)) #years, starting from 1
# timeseries for the first 10 locations
ts.plot(
  t(as.matrix(r[1:10])),
  gpars = list(lw = 3, col = hcl.colors(10, "Set 2"))
)
```

We sample random locations for the species and calculate its probability of detection based on species-specific parameters.

```
p <- runif(50, 0, 100)
p <- vect(matrix(p, ncol = 2))

# scaling predictors usually helps
r <- scale(r)
r_vals <- extract(r, p)

# demographic model
lambdat <- function(x, mu, sigl, sigr) {
  match.call
  u <- x - mu
  res <- NA * numeric(length(x))
  res[u <= 0] <- (u[u <= 0] / sigl[u <= 0]) ^ 2
  res[u > 0] <-(u[u > 0] / sigr[u > 0]) ^ 2
  return( exp(-0.5 * res) )
}

# detection model
detection_link <- function(x, c, pd) {
  return( 1 / (1 + exp( - (x - c) )) * pd )
}

pars <- list(mu = 0, sigl = 1, sigr = 2, c = -3, pd = 1)

lambda <- matrix(
  sapply(as.matrix(r_vals), lambdat, pars$mu, pars$sigl, pars$sigr),
  nrow = nrow(r_vals), ncol = ncol(r_vals)
)
plot(unlist(r_vals), lambda)
ltsgr <- rowMeans(log(lambda))
pr <- detection_link(ltsgr, c = pars$c, pd = pars$pd)

# sample occurrence from a bernoulli trial
p$occ <- rbinom(nrow(r_vals), 1, prob = pr)

niche <- lewontin_cohen(
  list(r), p,
  warmup = 300, iter = 600,
  refresh = 50, cores = 4
)

pars
summary(niche, c("mu", "sigl", "sigr", "c", "pd"))$summary
hist(rstan::extract(niche, c("mu"))$mu)
```
