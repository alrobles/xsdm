---
output: github_document
---

# Start of testing

```{r}
library(xsdm)
library(terra)

# a nice symmetric cliamte
mus <- rast(matrix(NA, 1e2, 1e2))
xy <- xyFromCell(mus, seq_len(ncell(mus)))
dist <- sqrt(rowSums( (xy - c(50, 50))^2 ))
values(mus)[, 1] <- dist
mus <- matrix(mus, nrow = 1e2, byrow = TRUE)

r <- array(NA, dim = c(1e2, 1e2, 30))
for (i in seq_len(nrow(r))) {
  for (j in seq_len(ncol(r))) {
    r[i, j, ] <- rnorm(30, mus[i, j], 15)
  }
}
r <- rast(r)
names(r) <- seq_len(nlyr(r)) #years, starting from 1
plot(c(mean(r), app(r, "sd")))

# uni-dimensional niche
lambda <- function(x, mu, sigl, sigr) {
  u <- x - mu
  u[u >= 0] <- (u[u > 0] / sigr) ^ 2  #> before <= ! danger zone
  u[u < 0] <- (u[u <= 0] / sigl) ^ 2
  lambda <- exp(-0.5 * u)
  return(lambda)
}

# probability of detection
pr <- function(x, c, pd) {
  return (pd / (1 + exp(c - x)))
}

# location vector
p <- runif(300, 0, 100)
p <- vect(matrix(p, ncol = 2))

# occurrence at locations
r_vals <- as.matrix(terra::extract(r, p))
scalings <- data.frame(
  avg = mean(as.matrix(r_vals)),
  std = sd(as.matrix(r_vals))
)
r_vals <- (r_vals - scalings$avg) / scalings$std  # scaling helps with fitting

# species parameters
pars <- list(mu = 0, sigl = 0.4, sigr = 0.2, c = -5, pd = 0.9)

lambdas <- lambda(
  as.matrix(r_vals),
  mu = pars$mu, sigl = pars$sigl, sigr = pars$sigr
)
ltsgr <- rowMeans(log(lambdas))
P <- pr(ltsgr, c = pars$c, pd = pars$pd)
p$occ <- rbinom(length(p), 1, prob = P)
table(p$occ)

oldpar <- par(no.readonly = TRUE)
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(
  sort(r_vals), lambdas[order(r_vals)], 
  type = "l", frame = FALSE,
  xlab = expression("Climate (e"[t]*")"),
  ylab = expression(lambda[t])
)
plot(
  rowMeans(r_vals), ltsgr, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "ltsgr"
)
plot(
  rowMeans(r_vals), P, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Probability of detection"
)
plot(
  rowMeans(r_vals), p$occ, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Occurrence"
)
lines(
  sort(r_vals), lambdas[order(r_vals)], 
  col = "dodgerblue", lw = 2
)
par(oldpar)

scaled_r <- (r - scalings$avg) / scalings$std
niche <- lewontin_cohen(
  list(scaled_r), p,  # first argument should always be a list
  warmup = 100, iter = 200,
  cores = 4, chains = 4,
  refresh = 10
)

rstan::traceplot(niche, pars = c("mu", "sigl", "sigr", "c", "pd"))
summary(niche, c("mu", "sigl", "sigr", "c", "pd"))$summary
rstan::extract(niche, c("mu"))

```

# End of testing

```





<!-- README.md is generated from README.Rmd. Please edit that file -->
<!-- You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# xsdm

<!-- badges: start -->
<!-- badges: end -->

The goal of xsdm is to model the distribution of species.
The main difference of xsdm from the other species' distribution models (SDMs) is that xsdm incorporate inter-annual climatic variabiliy when estimating the suitability of species.
This is achieved using theory from stochastic demography.

## Installation

You can install the development version of xsdm from GitHub using the `devtools` package:

``` r
devtools::install_github("emilio-berti/xsdm")
```

## XSDM using the Lewontin-Cohen model

For the sake of simplicity, we will focus on a species that has few recorded observations ($n = 20$) and which distribution depends only on one climatic predictor.
In general, we recommend to run XSDM for species that have at least $n = #$.
In addition, the distribution of most species is likely influenced by more than one climatic factor.

First we generate a fake time series of one climatic variable:

```{r timeseries}
library(xsdm)
library(terra)

# a nice symmetric cliamte
mus <- rast(matrix(NA, 1e2, 1e2))
xy <- xyFromCell(mus, seq_len(ncell(mus)))
dist <- sqrt(rowSums( (xy - c(50, 50))^2 ))
values(mus)[, 1] <- dist
mus <- matrix(mus, nrow = 1e2, byrow = TRUE)

r <- array(NA, dim = c(1e2, 1e2, 30))
for (i in seq_len(nrow(r))) {
  for (j in seq_len(ncol(r))) {
    r[i, j, ] <- rnorm(30, mus[i, j], 15)
  }
}
r <- rast(r)
names(r) <- seq_len(nlyr(r)) #years, starting from 1
plot(c(mean(r), app(r, "sd")))

# timeseries for 10 random locations
ts.plot(
  t(as.matrix(r[sample(seq_len(ncell(r)), 10)])),
  gpars = list(lw = 3, col = hcl.colors(10, "Set 2"))
)
```

Then, we create a virtual species with niche parameters `mu`, `sigl` and `sigr` and observation parameters `c` and `pd`.
We also sample location at which we sampled the occurrence of this species:

```{r virtual}
# uni-dimensional niche
lambda <- function(x, mu, sigl, sigr) {
  u <- x - mu
  u[u > 0] <- (u[u > 0] / sigr) ^ 2  #> before <= ! danger zone
  u[u <= 0] <- (u[u <= 0] / sigl) ^ 2
  lambda <- exp(-0.5 * u)
  return(lambda)
}

# probability of detection
pr <- function(x, c, pd) {
  return (pd / (1 + exp(c - x)))
}

# location vector
p <- runif(500, 0, 100)
p <- vect(matrix(p, ncol = 2))

# occurrence at locations
r_vals <- as.matrix(terra::extract(r, p))
scalings <- data.frame(
  avg = mean(as.matrix(r_vals)),
  std = sd(as.matrix(r_vals))
)
r_vals <- (r_vals - mean(r_vals)) / sd(r_vals)  # scaling helps with fitting

# species parameters
pars <- list(mu = 0, sigl = 0.4, sigr = 0.2, c = -3, pd = 0.9)

lambdas <- lambda(
  as.matrix(r_vals),
  mu = pars$mu, sigl = pars$sigl, sigr = pars$sigr
)
ltsgr <- rowMeans(log(lambdas))
P <- pr(ltsgr, c = pars$c, pd = pars$pd)
p$occ <- rbinom(length(p), 1, prob = P)
table(p$occ)
```

Let's look at the actual niche of this species:

```{r show}
oldpar <- par(no.readonly = TRUE)
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(
  sort(r_vals), lambdas[order(r_vals)], 
  type = "l", frame = FALSE,
  xlab = expression("Climate (e"[t]*")"),
  ylab = expression(lambda[t]),
)
plot(
  rowMeans(r_vals), ltsgr, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "ltsgr",
)
plot(
  rowMeans(r_vals), P, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Probability of detection",
)
plot(
  rowMeans(r_vals), p$occ, 
  frame = FALSE,
  xlab = "Mean climate",
  ylab = "Occurrence",
)
par(oldpar)
```

We are then ready to fit XSDM using the Lewontin-Cohen model and one climatic predictor: 

```{r xsdm, cache=TRUE}
scaled_r <- (r - scalings$avg) / scalings$std
niche <- lewontin_cohen(
  list(scaled_r), p,  # first argument should always be a list
  warmup = 100, iter = 200,
  cores = 4, chains = 4,
  refresh = 10
)

rstan::traceplot(niche, pars = c("mu", "sigl", "sigr", "c", "pd"))
summary(niche, c("mu", "sigl", "sigr", "c", "pd"))$summary
rstan::extract(niche, c("mu"))

```

